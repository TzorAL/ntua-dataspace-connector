# TSG Connector Helm Chart

This repository contains the Helm Chart for the TSG IDS Connector. It is the basis for deploying and configuring the components related to the connector (core container, administration UI, and data apps).

# Prerequisites

The following tools are required for the usage of Helm chart
- Configured `kubectl` CLI tool (https://kubernetes.io/docs/tasks/tools/)
- Helm CLI tool, preferable via one of the package managers (apt, pkg, homebrew, chocolatey) (https://helm.sh/docs/intro/install/)

Optional useful tools for deployment are:
- Lens, a graphical interface for Kubernetes with easy management of multiple clusters. (https://k8slens.dev)
- Helm-diff, an Helm plugin that allows to preview the changes of an Helm upgrade command (https://github.com/databus23/helm-diff)

Alternatively, tooling around your kubernetes may already provide Helm support (e.g. Rancher, Lens).

# Deployment

To deploy the Helm Chart create a `values.yaml` file, with the modifications to the configuration (see configuration options below). For the deployment you have to determine the Kubernetes namespace in which the deployment is deployed, as well as the deployment name which is used to prefix the Kubernetes resources generated by the Helm chart.

First, add the Helm repository of the TSG components:
```bash
helm repo add tsg https://nexus.dataspac.es/repository/tsg-helm
```
To install the Helm chart, execute:
```bash
helm install --create-namespace -n NAMESPACE DEPLOYMENT_NAME tsg/tsg-connector --version 3.2.4 -f values.yaml
```

After that, to upgrade the deployment execute:
```bash
helm upgrade -n NAMESPACE DEPLOYMENT_NAME tsg/tsg-connector --version 3.2.4 -f values.yaml
```

> _**NOTE**_: The install & upgrade commands can also be merged into one command that can be executed regardless of whether there is an existing deployment:
> ```bash
> helm upgrade --install --create-namespace -n NAMESPACE DEPLOYMENT_NAME tsg/tsg-connector --version 3.2.4 -f values.yaml
> ```

To delete the connector and remove all related resources:
```
helm uninstall -n NAMESPACE DEPLOYMENT_NAME
```

## Helm diff plugin

To preview the changes of `helm upgrade` on the cluster, the [Helm diff](https://github.com/databus23/helm-diff) tool can be very useful. It shows in a diff-like fashion what will be changed in the resources, and can act as sanity check to make sure no errors are made.

To run the Helm diff plugin, simply replace `helm upgrade` with `helm diff upgrade`.

> _**NOTE**_: The Helm diff plugin does not support the `--install` and `--create-namespace` options used in the `helm upgrade` command above.
> To remedy this, either remove these options or set the `HELM_DIFF_IGNORE_UNKNOWN_FLAGS` to `true`, eg:
> ```bash
> helm diff upgrade -n NAMESPACE DEPLOYMENT_NAME tsg/tsg-connector --version 3.2.4 -f values.yaml
> HELM_DIFF_IGNORE_UNKNOWN_FLAGS=true helm upgrade --install --create-namespace -n NAMESPACE DEPLOYMENT_NAME tsg/tsg-connector --version 3.2.4 -f values.yaml
> ```

# Configuration

The minimal configuration required to get your first deployment running, without data apps and ingresses, is as follows:

```yaml
ids:
  info:
    idsid: IDS_COMPONENT_ID
    curator: IDS_PARTICIPANT_ID
    maintainer: IDS_PARTICIPANT_ID
    titles:
      - CONNECTOR TITLE@en
    descriptions:
      - CONNECTOR DESCRIPTION@en
    accessUrl:
      - https://CONNECTOR_ACCESS_URL/router
```

With this configuration, it is assumed you want to use the SCSN Test DAPS and SCSN Test Broker, see _IDS Identity_ to connect to a different dataspace. Also no method of receiving messages of other connectors is defined, see _Ingress_ below to configure the ingress to your connector.

The security of the API of the Core Container can be configured in a way that only authorized users or authorized API keys can access certain functionality of the Core Container, see _Security_ for more information.

All of the configurable properties that can be used to further specify how your connector will run are listed below under _Values_.

## IDS Identity

The default way of providing the IDS Identity for your connector is by using a Kubernetes secret. It is recommended to provide this secret outside of the Helm chart to prevent leaking your private key in the deployment configuration.

To create a secret (based on the following files: `component.crt`, `component.key`, `cachain.crt`) execute:
```bash
kubectl create secret generic \
    -n NAMESPACE \
    ids-identity-secret \
    --from-file=ids.crt=./component.crt \
    --from-file=ids.key=./component.key \
    --from-file=ca.crt=./cachain.crt
```

> _**NOTE**_: The secret must be created in the same namespace as the connector deployment

Important to keep in mind is to make sure the IDS Identity you're using matches the DAPS (`ids.daps.url`) and Broker (`ids.broker.id` & `ids.broker.address`) configuration.

The secret can also be created via the Helm chart, by setting the `coreContainer.secrets.idsIdentity.existing` to `false` and by providing the certificate details in `coreContainer.secrets.idsIdentity.data`

## Ingress

To allow communication from outside the network to one of the components, it is required to explicitly configure this. Either via Ingress resources (preferred) or NodePort services.

For the Ingress resources, it is assumed there is an [NGINX Ingress Controller](https://kubernetes.github.io/ingress-nginx/) available in the network. Other Ingress controllers might also work, but the annotations for this must be provided manually.

There are three places ingress configuration is present: `coreContainer.ingress`, `adminUi.ingress`, `containers[].services[].ingress`. All of these follow the same structure:
```yaml
# -- Ingress path
path: /(.*)
# -- (Optional) Ingress rewrite target
rewriteTarget: /$1
# -- (Optional) Ingress clusterIssuer for automatic TLS certificate request by Cert Manager
clusterIssuer: letsencrypt
# -- (Optional) Ingress secretName containing TLS details, by default the hostname appended with "-tls" will be used
secretName:
# -- (Optional) Ingress host override
host: connector-cc.domain.com
# -- (Optional) Ingress additional annotations
annotations: {}
```

The `path` is the publicly accessible path which is routed to the corresponding pod, this can be a regular expression. The `rewriteTarget` rewrites the `path` into an URI that is called on the backend service, regular expression groups in the `path` can be used with the `$` prefix.

The `clusterIssuer` property can be used to provide a reference to a `ClusterIssuer` that can be used by [cert-manager](https://cert-manager.io/docs/) to automatically request TLS certificates for the Ingress (e.g. via LetsEncrypt). The `secretName` is the TLS secret name that is used for TLS termination by the Ingress Controller, if `cert-manager` is used the secret does not have to exist but if you want to provide an existing TLS certificate it should be provided in this secret.

The `host` property sets the hostname for the ingress, if this is not provided the root value of `host` is used.

Lastly, the `annotations` property allows for adding additional annotations to the Ingress resource. For the NGINX Ingress Controller quite some [annotations](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/) are available to configure its behaviour (e.g. authentication, maximum body size)

# Security

To enable the security of the Core Container internal API, set `ids.security.enabled` to `true` (default). This makes sure that the Core Container allows only authorized requests from internal applications and administrative users.

By default, if no administrative users are provided in the `ids.security.users` block, a default administrative user is created with a randomly generated password. This password is shown in the logs of the core container on startup.

For the API keys, no default keys are generated if none is provided. So to be able to use data apps in a situation where security is enabled one **must** provide API keys in the configuration. These API keys should then be configured in the data apps with the `containers[].apiKey` property to inject this configuration into the data app.

It is important to always use the least-privilege principle in mind when creating users and API keys, by selecting only the roles that the user or API key should have access to. A list of roles is shown below, but please have a look at the Core Container documentation to check the latest state:
- **ADMIN**: Administrator role for the primary administrator that has full access and inherits all of the other roles
- **DATA_APP**: Data App role that can be given to Data Apps for managing the resources that they offer
- **READER**: Reader role that is allowed to read all resources in the core container but not modify them
- **ARTIFACT_PROVIDER_MANAGER**: Artifact Provider Manager role that is allowed to administrate provided artifact
- **ARTIFACT_PROVIDER_READER**: Artifact Provider Reader role that is allowed to list provided artifacts
- **ARTIFACT_CONSUMER**: Artifact Consumer role that is allowed to request artifacts from other connectors in the network
- **ORCHESTRATION_MANAGER**: Orchestration Manager role that is allowed to orchestrate containers
- **ORCHESTRATION_READER**: Orchestration Reader role that is allowed to list orchestrated containers
- **PEF_MANAGER**: Policy Enforcement Manager role that is allowed to initiate new contracts and contract negotiations
- **PEF_READER**: Policy Enforcement Reader role that is allowed to list agreed upon contracts and contract offers
- **RESOURCE_MANAGER**: Resource Manager role that is allowed to modify the resources provided by the core container and data apps
- **RESOURCE_READER**: Resource Reader role that is allowed to list resources provided by the core container and data apps
- **ROUTE_MANAGER**: Route Manager role that is allowed to modify Camel routes offered by the Core Container
- **ROUTE_READER**: Route Reader role that is allowed to list Camel routes offered by the Core Container
- **DESCRIPTION_READER**: Description Reader role that is allowed to send Description Request messages to other connectors in the network
- **WORKFLOW_MANAGER**: Workflow Manager role that is allowed to initiate new workflows
- **WORKFLOW_READER**: Workflow Reader role that is allowed to list workflows and show the results and status of the workflow

# Examples

There are two example configurations that show how the values can be set in practice, as this Helm chart allows for a large variety of configuration these examples can be used as starting point for your configuration.
The examples are:
* _OpenAPI Deployment_ (`/examples/default-openapi-deployment/`): An OpenAPI data app deployment of the TSG connector with Policy Enforcement enabled.
* _Standalone Core Container_ (`/examples/standalone-core-container/`): An standalone core container deployment, for usage of just the core container without any data apps.

# Values

The TSG Connector Helm Chart allows for a lot of configurability to allow for the deployment to fit into your needs. A couple of configuration groups are distinguished: generics, core container, admin UI, IDS configuration, data apps & helpers. Each of the groups are detailed below.

## Generics

The generic configuration applies to a large part of the resources generated for the connector. Especially the `host` property might be of interest if you want to expose all of the ingress resources on the same domain name. The other properties are only required in specific cases.

| <div style="width: 400px">Key</div> | <div style="width: 50px">Type</div> | <div style="width: 300px">Default</div> | Description |
|-----|------|---------|-------------|
| pullSecret.name | string | `nil` | (Optional) Kubernetes pullsecret name for connecting to a private Docker registry. Leave empty for default behaviour |
| pullSecret.credentials.registry | string | `nil` | (Optional) Docker registry for embedded pull credentials |
| pullSecret.credentials.username | string | `nil` | (Optional) Username for authentication with the Docker registry |
| pullSecret.credentials.password | string | `nil` | (Optional) Password for authentication with the DOcker registry |
| host | string | `nil` | (Optional) Default host for ingress resources |
| useNewIngress | bool | `true` | Use new Kubernetes ingress apiVersion `networking.k8s.io/v1` (for K8s >=v1.19) instead of `extensions/v1beta1` (for K8s <=v1.21) for all Ingress resources |
| deployment.annotations | object | `{}` | Annotations applied to the core-container and data apps configured in containers |
| deployment.pullPolicy | string | `"Always"` | Pull policy for all data apps configured in `values`, either `Always`, `IfNotPresent`, `Never` |

## Core Container

The core container configuration configures how the core container pod and related resources are deployed. Especially the `ingress` block is important if you want to safely expose the core container to the outside world.

The `secrets.idsIdentity` property can be used to modify the default behaviour of the Kubernetes secret containing the IDS identity.

| <div style="width: 400px">Key</div> | <div style="width: 50px">Type</div> | <div style="width: 300px">Default</div> | Description |
|-----|------|---------|-------------|
| coreContainer.replicaCount | int | `1` | Replicas as specified in the core container deployment |
| coreContainer.image | string | `"docker.nexus.dataspac.es/core-container:master"` | Core Container docker image name |
| coreContainer.environment | list | `nil` | (Optional) Environment variable configuration, follows Kubernetes environment definition style with support for Secret injection |
| coreContainer.nodePort.api | int | `nil` | (Optional) NodePort Service configuration for direct exposing the Core Container API (not preferred) |
| coreContainer.nodePort.camel | int | `nil` | (Optional) NodePort Service configuration for direct exposing the Core Container Camel routes (not preferred) |
| coreContainer.ingress.path | string | `"/(.*)"` | Ingress path |
| coreContainer.ingress.rewriteTarget | string | `nil` | (Optional) Ingress rewrite target |
| coreContainer.ingress.clusterIssuer | string | `nil` | (Optional) Ingress clusterIssuer for automatic TLS certificate request by Cert Manager |
| coreContainer.ingress.secretName | Optional | `nil` | Ingress secretName containing TLS details, by default the hostname appended with "-tls" will be used |
| coreContainer.ingress.host | string | `nil` | (Optional) Ingress host override |
| coreContainer.ingress.annotations | object | `nil` | (Optional) Ingress additional annotations |
| coreContainer.apiIngress.enabled | bool | `false` | (Optional) Enable exposing the /api endpoint of the Core Container via the ingress |
| coreContainer.secrets.idsIdentity.enabled | bool | `true` | Enable IDS identity Kubernetes secret |
| coreContainer.secrets.idsIdentity.name | string | `"ids-identity-secret"` | IDS Identity Kubernetes secret name |
| coreContainer.secrets.idsIdentity.existing | bool | `true` | Use existing pre-provisioned Kubernetes secret, preferred due to security of the secret |
| coreContainer.secrets.idsIdentity.data."ids.crt" | string | `nil` | IDS Identity certificate value |
| coreContainer.secrets.idsIdentity.data."ids.key" | string | `nil` | IDS Identity private key value |
| coreContainer.secrets.idsIdentity.data."ca.crt" | string | `nil` | IDS Identity Certificate chain value |
| coreContainer.persistentVolume.name | string | `nil` | (Optional) Persistent Volume name |
| coreContainer.persistentVolume.mountPath | string | `nil` | (Optional) Mount Path inside the container |
| coreContainer.persistentVolume.storageSize | string | `nil` | (Optional) Storage Size |
| coreContainer.persistentVolume.storageClassName | string | `default` | (Optional) Storage class name |
| coreContainer.persistentVolume.disalbeClaim | bool | `false` | (Optional) Disable persistent volume claim creation, e.g. when you want to use an existing claim |
| coreContainer.updateStrategy.type | string | `nil` | (Optional) Deployment update strategy, defaults to RollingUpdate might require changes in case of PVC usage |

## Admin User Interface

The Admin UI primarily consist of the configuration for exposing the UI, but the UI can also be replaced by another UI via the `image` property.

| <div style="width: 400px">Key</div> | <div style="width: 50px">Type</div> | <div style="width: 300px">Default</div> | Description |
|-----|------|---------|-------------|
| adminUi.enabled | bool | `true` | Toggle for enabling the Core Container Administration UI  |
| adminUi.image | string | `"docker.nexus.dataspac.es/core-container-ui:master"` | Docker image to use for the UI |
| adminUi.ingress.path | string | `"/(.*)"` | Ingress path |
| adminUi.ingress.rewriteTarget | string | `nil` | (Optional) Ingress rewrite target |
| adminUi.ingress.clusterIssuer | string | `nil` | (Optional) Ingress clusterIssuer for automatic TLS certificate request by Cert Manager |
| adminUi.ingress.secretName | Optional | `nil` | Ingress secretName containing TLS details, by default the hostname appended with "-tls" will be used |
| adminUi.ingress.host | string | `nil` | (Optional) Ingress host override |
| adminUi.ingress.annotations | object | `{}` | (Optional) Ingress additional annotations |
| adminUi.nodePort | int | `nil` | Configure NodePort service for the UI |
| adminUi.updateStrategy.type | string | `nil` | (Optional) Deployment update strategy, defaults to RollingUpdate might require changes in case of PVC usage |

## IDS Configuration (Core Container)

The IDS Configuration provides the configuration used within the core container. See the [Core Container Documentation](#TODO) for the available properties.

| <div style="width: 400px">Key</div> | <div style="width: 50px">Type</div> | <div style="width: 300px">Default</div> | Description |
|-----|------|---------|-------------|
| ids.info.idsid | string | `"IDS_COMPONENT_ID"` | IDS Component Identity (URI based identifier) |
| ids.info.curator | string | `"IDS_PARTICIPANT_ID"` | IDS Participant Identity, aimed at the participant that is responsible for the contents of the connector (URI based identifier) |
| ids.info.maintainer | string | `"IDS_PARTICIPANT_ID"` | IDS Participant Identity, aimed at the participant that is responsible for the technical side of the connector (URI based identifier) |
| ids.info.titles | list | `["CONNECTOR TITLE@en"]` | Title of the Connector  |
| ids.info.descriptions | list | `["CONNECTOR DESCRIPTION@en"]` | Description of the Connector |
| ids.info.accessUrl | list | `["https://{{ .Values.host }}/router"]` | Publicly accessible access URL(s) of the Connector |
| ids.daps.url | string | `"https://daps.test.ids.smart-connected.nl"` | Dynamic Attribute Provisioning Service URL |
| ids.keystore.type | string | `"PEM"` | Keystore encoding type |
| ids.keystore.pem.cert | string | `"file:/secrets/idsidentity/ids.crt"` | File, Base64 encoded, or plain PEM certificate, defaults to secret based file value |
| ids.keystore.pem.key | string | `"file:/secrets/idsidentity/ids.key"` | File, Base64 encoded, or plain PKCS#8 private key, defaults to secret based file value |
| ids.truststore.type | string | `"PEM"` | Truststore encoding type |
| ids.truststore.pem.chain | string | `"file:/secrets/idsidentity/ca.crt"` | File, Base64 encoded, or plain PEM certificate list, defaults to secret based file value |
| ids.broker.id | string | `"urn:ids:connectors:Broker"` | Broker IDS Identifier |
| ids.broker.address | string | `"https://broker.test.ids.smart-connected.nl"` | Broker Access URL |
| ids.broker.autoRegister | bool | `true` | Automatically register the connector at startup |
| ids.routes.ingress.http[].endpoint | string | `router` | Exposed public endpoint |
| ids.routes.ingress.http[].dataApp | string | `nil` | Data App endpoint the requests are routed to |
| ids.routes.ingress.http[].parameters | string | `nil` | (Optional) Additional Camel parameters for the route |
| ids.routes.ingress.http[].policyEnforcement | bool | `false` | (Optional) Enable policy enforcement for this route |
| ids.routes.ingress.http[].delegatedPolicyNegotiation | bool | `false` | (Optional) Enable delegated policy negotiation (i.e. the Data App is responsible for the contract negotiation process) |
| ids.routes.ingress.idscp[].port | int | `nil` | Exposed public port for IDSCP |
| ids.routes.ingress.idscp[].dataApp | string | `nil` | Data App endpoint the requests are routed to |
| ids.routes.ingress.idscp[].tlsClientHostnameVerification | bool | `true` | (TLS Client hostname verification |
| ids.routes.egress.http[].endpoint | string | `router` | Internal endpoint exposed by the core container for receiving messages intended for egress |
| ids.routes.egress.idscp[].endpoint | string | `router` | Internal endpoint exposed by the core container for receiving messages intended for egress |
| ids.workflow.incrementalIds | bool | `true` | Use incremental IDs for workflows (for testing purposes only) |
| ids.workflow.type | string | `"IDS"` | Type of Workflows |
| ids.workflow.internalHostname | string | `"{{ template \"tsg-connector.fullname\" . }}"` | Internal hostname of the core container (must be reachable from apps started by the core container), defaults to the internal Kubernetes service name of the Core Container |
| ids.workflow.useOrchestration | bool | `true` | Use the embedded Orchestration Manager for starting apps |
| ids.orchestrationManagerConfig.enableKubernetes | bool | `true` | Enable Kubernetes orchestration (auto-configuring when deployed in a Kubernetes environment) |
| ids.orchestrationManagerConfig.pullSecretName | string | `nil` | (Optional) Default Pull Secret to use for apps  |
| ids.security.enabled | bool | `true` | Enable the security feature and block all unauthorized requests to the API |
| ids.security.apiKeys[].id | string | `nil` | API Key identifier |
| ids.security.apiKeys[].key | string | `nil` | API Key (must start with "APIKEY-") |
| ids.security.apiKeys[].roles | list | `nil` | API Key role assignments |
| ids.security.users[].id | string | `nil` | User identifier (also used as username for the user) |
| ids.security.users[].password | string | `nil` | BCrypt encoded password |
| ids.security.users[].roles | list | `nil` | User role assignments |

## Data Apps & Helpers

The configuration for data apps and helper containers provide the most configurability, specifically to allow setting various Kubernetes settings for the deployment of these containers.

The `type` of the container must be set properly, especially if you want to use the container as data app. Since configuration for interoperability with the core container will be generated for data apps.

| <div style="width: 400px">Key</div> | <div style="width: 50px">Type</div> | <div style="width: 300px">Default</div> | Description |
|-----|------|---------|-------------|
| containers[].type | string | `"data-app"` | Container Type. Either `data-app` (for data-app containers healthchecks and configuration are configured out of the box) or `helper` |
| containers[].name | string | `"data-app-container"` | Container Name |
| containers[].image | string | `"data-app-container-image:latest"` | Container Image (including tag) |
| containers[].apiKey | string | `nil` | (Optional) Core Container API Key |
| containers[].validateResources.enabled | bool | `true` | Validate state of resource metadata present at the core container  |
| containers[].validateResources.interval | int | `30000` | Validation interval in milliseconds |
| containers[].cacheInvalidationPeriod | int | `1800000` | Broker cache entry invalidation period in milliseconds |
| containers[].idsConfig | object | `nil` | (Optional) Extra IDS configuration properties |
| containers[].config | object | `nil` | (Optional) Data App specific configuration properties |
| containers[].services[].port | int | `8080` | Port number for both container as services |
| containers[].services[].name | string | `"http"` | Port name |
| containers[].services[].nodePort | int | `nil` | (Optional) NodePort configuration |
| containers[].services[].ingress.path | string | `"/(.*)"` | Ingress path |
| containers[].services[].ingress.rewriteTarget | string | `nil` | (Optional) Ingress rewrite target |
| containers[].services[].ingress.clusterIssuer | string | `nil` | (Optional) Ingress clusterIssuer for automatic TLS certificate request by Cert Manager |
| containers[].services[].ingress.secretName | Optional | `nil` | Ingress secretName containing TLS details, by default the hostname appended with "-tls" will be used |
| containers[].services[].ingress.host | string | `nil` | (Optional) Ingress host override |
| containers[].services[].ingress.annotations | object | `nil` | (Optional) Ingress additional annotations |
| containers[].environment | list | `nil` | Environment variable configuration list, can be name-value objects or name-valueFrom objects |
| containers[].hostPath | object | `nil` | (Optional) HostPath Volume configuration. For mounting hostPath volumes to the container, primarily used for testing in local (e.g. Docker-Desktop) clusters |
| containers[].hostPath.mountPath | string | `nil` | (Optional) Mount Path inside the container |
| containers[].hostPath.name | string | `nil` | (Optional) HostPath name |
| containers[].hostPath.path | string | `nil` | (Optional) Mount Path on the host. Note: for Docker-Desktop WSL(2) clusters, the prefix for the windows host is /run/desktop/mnt/host |
| containers[].secrets[].name | string | `nil` | Secret name |
| containers[].secrets[].mountPath | string | `nil` | Secret mount path |
| containers[].persistentVolume.name | string | `nil` | (Optional) Persistent Volume name |
| containers[].persistentVolume.mountPath | string | `nil` | (Optional) Mount Path inside the container |
| containers[].persistentVolume.storageSize | string | `nil` | (Optional) Storage Size |
| containers[].persistentVolume.storageClassName | string | `default` | (Optional) Storage class name |
| containers[].persistentVolume.disalbeClaim | bool | `false` | (Optional) Disable persistent volume claim creation, e.g. when you want to use an existing claim |
| containers[].resources | object | `nil` | (Optional) Resource constraint configuration (see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) |
| containers[].command | list | `nil` | (Optional) Command (equivalent to Docker Entrypoint) override |
| containers[].args | list | `nil` | (Optional) Argument (equivalent to Docker CMD) override |
| containers[].securityContext.runAsUser | int | `nil` | (Optional) Linux user id used for the root process |
| containers[].securityContext.runAsGroup | int | `nil` | (Optional) Linux user group used for the root process |
| containers[].updateStrategy.type | string | `nil` | (Optional) Deployment update strategy, defaults to RollingUpdate might require changes in case of PVC usage |
